# 직렬화된 인스턴스 대신 직렬화 프록시 사용을 검토하라
`Serializable`을 구현하기로 결정한 순간 언어의 정상 메커니즘인 생성자 이외의 방법으로 인스턴스를 생성할 수 있게 된다.  
이는 버그와 보안 문제가 일어날 가능성이 커진다는 뜻이다.  
하지만 이 위험을 크게 줄여줄 기법인 **직렬화 프록시 패턴 (Serailization proxy pattern)**이 존재한다.


## 직렬화 프록시 패턴

바깥 클래스의 논리적 상태를 정밀하게 표현하는 중첩 클래스를 설계해 `private static`으로 선언한다.  
이 중첩 클래스가 바로 바깥 클래스의 **직렬화 프록시**이다.

### 주의사항
- 중첩 클래스의 생성자는 단 하나여야 하며, 바깥 클래스를 매개변수로 받아야 한다.  
- 중첩 클래스의 생성자는 단순히 인수로 넘어온 인스턴스의 데이터를 복사한다.
- 바깥 클래스와 직렬화 프록시 모두 `Serializable`을 구현한다고 선언해야 한다.

### Period 클래스용 직렬화 프록시
``` java
private static class SerializationProxy implement Serializable {
  private final Date Start;
  private final Date end;
  
  SerializationProxy(Period p) {
    this.start = p.start;
    this.end = p.end;
  }
  
  private static final long serialVersionUID =
    234098243823485285L; // 아무 값이나 상관없다. (아이템 87)
  
}
```

### 직렬화 프록시 패턴용 writeReplace 메서드
다음으로, 바깥 클래스에 아래의 `writeReplace` 메서드를 추가한다.  
이 메서드는 범용적이니 직렬화 프록시를 사용하는 모든 클래스에 그대로 복사해 쓰면 된다.

``` java
private Object writeReplace() {
  return new SerializationProxy(this);
}
```

이 메서드는 자바의 직렬화 시스템이 바깥 클래스의 인스턴스 대신 `SerializationProxy` 의 인스턴스를 반환하게 하는 역할을 한다.  
즉, 직렬화가 이뤄지기 전에 바깥 클래스의 인스턴스를 직렬화 프록시로 변환해준다.  

`writeReplace` 덕분에 직렬화 시스템은 결코 바깥 클래스의 직렬화된 인스턴스를 생성해낼 수 없다.  

### 직렬화 프록시 패턴용 readObject 메서드
l


### EnumSet의 직렬화 프록시
``` java
private static class SerializationProxy <E extend Enum<E>> 
        implement Serializable {
  // 이 EnumSet의 원소 타입
  private final Class<E> elementTpe;
  
  // 이 EnumSet 안의 원소들
  private final Enum<?>[] elements;
  
  private Object readResolve() {
    EnumSet<E> result = EnumSet.noneOf(elementType);
    for (Enum<?> e : elements) {
      result.add((E)e);
    }
    return result;
  }
  
  private static final long serialVersionUID =
    362491234563181265L;
}
```

## 직렬화 프록시 패턴의 한계
### 클라이언트가 멋대로 확장할 수 있는 클래스에는 적용할 수 없다.
> 아이템 19 참조
> 
