# 아이템 49. 매개변수가 유효한지 검사하라.

메서드와 생성자 대부분은 입력 매개변수의 값이 특정 조건을 만족하기를 바란다. 이는 "오류는 가능한 한 빨리 (발생한 곳에서) 잡아야 한다"는 일반 원칙의 한 사례이기도 하다. 
오류를 발생한 즉시 잡지 못하면 해당 오류를 감지하기 어려워지고, 감지하더라도 오류의 발생 지점을 찾기 어려워진다.  
메서드 몸체가 실행되기 전에 매개변수를 확인한다면 잘못된 값이 넘어왔을 때 즉각적이고 깔끔한 방식으로 예외를 던질 수 있다.  

### 매개변수 검사를 제대로 하지 못하면 몇 가지 문제가 생길 수 있다. 
1. 메서드가 수행되는 중간에 모호한 예외를 던지며 실패할 수 있다.
2. 메서드가 잘 수행되지만 잘못된 결과를 반환할 수 있다.
3. 메서드는 문제없이 수행됐지만, 어떤 객체를 이상한 상태로 만들어 미래의 알 수 없는 시점에 이 메서드와는 관련 없는 오류를 낼 수 있다.
매개변수 검사에 실패하면 `실패 원자성(failure atomicity)`(아이템 76)을 어기는 결과를 낳을 수 있다.
> 실패원자성 : 일반적으로 호출된 메소드가 실행에 실패하더라도 객체 상태는 메소드 호출 전과 같아야 함  


## public, protected 메서드는 @throws 자바독 태그를 사용해 던지는 예외를 문서화 하자
보통은 `IllegalArgumentException`, `IndexOutOfBoundsException`, `NullPointerException` 중 하나가 될 것이다.  
또한 매개변수의 제약을 문서화 한다면, 그 제약을 어겼을 때 발생하는 예외도 함께 기술해야 한다.   
```Java
/**
*
* @param m 계수(양수여야함)
* @return 현재 값 mod m
* @throws ArithmeticException if m <= 0.
*/
public BigInteger mod(BigInteger m) {
 if (m.signum() <= 0)
 throw new ArithmeticException("계수(m)은 양수여야 합니다. " + m);
 ... // 계산 
}
```
이 메서드는 m이 null이면 m.signum() 호출 시 `NullPointerException`을 던진다.
그런데 "m이 null일 때 NullPointerException을 던진다"라는 말은 메서드 설명 어디에도 없다.
그 이유는 이 설명을 개별 메서드가 아닌 BitInteger 클래스 수준에서 기술했기 떄문이다.  
**클래스 수준 주석은 그 클래스의 모든 public 메서드에 적용되므로 각 메서드에 일일이 기술하는 것보다 깔끔한 방법이다.**  
@Nullable이나 다른 방법들이 있지만 표준적인 방법이 아니다.  

**자바 7에 추가된 java.util.Objects.requireNonNull 메서드는 유연하고 사용하기 편하며, 더이상 null 검사를 수동으로 하지 않아도 된다.**  
```Java
this.strategy = Objects.requireNonNull(strategy ,"전략");
```

자바 9에서는 Objects에 범위 검사 기능이 더해졌다. `checkFromIndexSize`, `checkFromToIndex`, `checkIndex` 메서드 들이다.
null 검사 메서드만큼 유연하지 않고, 예외메세지를 지정할 수 없으며, 리스트와 배열 전용으로 설계됬다. 
또한 닫힌 범위(closed range; 양 끝단의 값을 포함하는)는 다루지 못한다. 하지만 이런 제약이 방해되지 않는 상황에서는 아주 유용하고 편리하다. 

## public이 아닌 메서드라면 단언문(assert)을 사용해 매개변수 유효성을 검증하자 
공개되지 않은 메서드라면 패키지 제작자가 메서드가 호출되는 상황을 통제할 수 있다. 따라서 오직 유효한 값만이 메서드에 넘겨지리라는 것을 보증할 수 있다.  
다시 말해 public이 아닌 메서드라면 단언문(assert)을 사용해 매개변수 유효성을 검증할 수 있다.

```Java
/* 재귀 정렬용 private 도우미 함수 */
private static void sort(long a[], int offset, int length){
    assert a != null;
    assert offset >= 0 && offset <= a.length;
    assert length >= 0 && length <= a.length - offset;
    ... // 계산 수행
}
```
이 단언문들은 자신이 단언한 조건이 무조건 참이라고 선언한다.

### 단언문이 일반적인 유효성 검사와 다른 점
1. 실패하면 AssertionError를 던진다.
2. 런타임에 아무런 효과도, 아무런 성능 저하도 없다.  
(단, java를 실행할 때 명령줄에서 -ea 혹은 --enableassertions 플래그 설정하면 런타임에 영향을 준다.)  

메서드가 직접 사용하지는 않으나 나중에 쓰기 위해 저장하는 매개변수는 특히 더 신경 써서 검사해야 한다.  
```Java
/* 입력받은 Int 배열의 List 뷰를 반환하는 메서드 */ 
static List<Integer> intArrayAsList(int[] a){
    Objects.requireNonNull(a);
    
    return new AbstractList<>(){
        ...
    };
}
```
만약 requireNonNull 메서드를 통한 검사를 생략했다면, 이 메서드를 사용해 List 인스턴스를 돌려받은 후 이용하려 할 때 비로소 NullPointerException 발생한다.
이 때가 되면 원인을 추적하기 어렵게 하고, 디버깅이 괴로워질 수 있다.  
특히나 생성자 매개변수의 유효성 검사는 클래스 불변식을 어기는 객체가 만들어지지 않게 하는데 꼭 필요하다.  

## 예외
메서드 몸체 실행 전에 매개변수 유효성을 검사해야 한다는 규칙에도 **예외**는 있다.
- 유효성 검사 비용이 지나치게 높거나 실용적이지 않을 때 
- 계산 과정에서 암묵적으로 검사가 수행될 때 
> 예) Collections.sort(List) 객체 리스트를 정렬하는 메서드  
> 리스트 안의 객체들은 모두 상호 비교될수 있어야 하며, 비교될 수 없는 타입의 객체가 들어있다면 그 객체와 비교할 때 ClassCastException 던진다.   
> 따라서 비교하기 앞서 미리 모든 객체가 상호 비교가능한지 검사하는 건 별다른실익이 없다.  

하지만 암묵적 유효성 검사에 너무 의존했다가는 실패 원자성을 해칠 수 있으니 주의하자.

## 예외 번역 관용구
때로는 계산 과정에서 필요한 유효성 검사가 이뤄지지만 실패했을 때 잘못된 예외를 던지기도 한다.  
계산 중 잘못된 매개변수 값을 사용해 발생한 예외는 **예외 번역(exception translate) 관용구**를 사용해 API 문서에 기재된 예외로 번역하자.  

## 핵심 정리
메서드는 최대한 범용적으로 설계해야 한다. 메서드가 건네받은 값으로 무언가 제대로 된 일을 할 수 있다면 **매개변수 제약은 적을 수록 좋다.**
> 메서드나 생성자를 작성할 때 그 매개변수들에 어떤 제약이 있을지 생각해야 한다.  
> 그 제약들을 문서화하고 메서드 코드 시작 부분에서 명시적으로 검사해야 한다. 
