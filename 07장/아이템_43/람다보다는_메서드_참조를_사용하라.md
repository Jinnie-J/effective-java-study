# 아이템 43. 람다보다는 메서드 참조를 사용하라.

- 람다가 익명 클래스보다 나은 점 중에서 가장 큰 특징은 간결함이다.
- 그런데 자바에는 함수 객체를 람다보다도 더 간결하게 만드는 방법이 있으니, 바로 **메서드 참조(method reference)** 다.

## 메서드 참조

다음 코드는 임의의 키와 Integer 값의 매핑을 관리하는 프로그램의 일부다.   
이 코드는 키가 맵 안에 없다면 키와 숫자 1을 매핑하고, 이미 있다면 기존 매핑 값을 증가시킨다.

```Java
map.merge(key, 1, (count, incr) -> count + incr);
```

깔끔해 보이지만 거추장스러운 부분이 남아 있다. 매개변수인 count와 incr은 크게 하는 일 없이 공간을 꽤 차지한다.  
자바 8이 되면서 Integer 클래스는 이 람다와 기능이 같은 정적 메서드 sum을 제공하기 시작했다.  

```Java
map.merge(key, 1, Integer::sum);
```

### 메서드 참조의 장점 
- 똑같은 결과를 더 보기 좋게 표현할 수 있다
- 매개변수 수가 늘어날수록 메서드 참조로 제거할 수 있는 코드양도 늘어난다.

## 메서드 참조 사용 시 주의사항
- 어떤 람다에서는 매개변수의 이름 자체가 프로그래머에게 좋은 가이드가 되기도 한다.  
- 이런 람다의 경우 길이는 더 길지만 메서드 참조보다 읽기 쉽고 유지보수도 쉬울 수 있다.  
- 람다로 할 수 없는 일이라면 메서드 참조로도 할 수 없다. (예외 존재)

- IDE들은 람다를 메서드 참조로 대체하라고 권할 것이다. IDE의 권고를 따르는 게 보통은 이득이지만, 항상 그런 것은 아니다.  
  때론 람다가 메서드 참조보다 간결할 때가 있다. 주로 메서드와 람다가 같은 클래스에 있을 때 그렇다.  

예를 들어 다음 코드가 GoshThisClassNameIsHumongous 클래스 안에 있다고 해보자.

```Java
service.execute(GoshThisClassNameIsHumongous::action);
```

이를 람다로 대체하면 다음처럼 된다.

```Java
service.excute(() -> action());
```

- 같은 예로 `java.util.function` 패키지가 제공하는 제네릭 정적 팩터리 메서드인 `Function.identity()`를 사용하기보다는 똑같은 기능의 람다`(x -> x)`를 직접 사용하는 편이 코드도 짧고 명확하다.

### 메서드 참조의 유형
1. 정적 메서드를 가리키는 메서드 참조 
- 가장 흔한 메서드 참조 유형으로 정적 메서드를 참조한다.
```Java
//메서드 참조 (정적 메소드가 포함된 클래스::정적 메소드명)
Interger::parseInt 

//람다
str -> Integer.parseInt
```
2. 한정적(bound) 인스턴스 메서드 참조
- 수신 객체(receiving object; 참조 대상 인스턴스)를 특정하는 한정적 인스턴스 메서드 참조
- 한정적 참조는 근본적으로 정적 참조와 비슷하다. 즉, 함수 객체가 받는 인수와 참조되는 메서드가 받는 인수가 똑같다. 
```Java
//메서드 참조 (메소드가 포함된 객체::메소드명)
Instant.now()::isAfter()

//람다
Instant then = Instant.now();
t -> then.isAfter(t)
```
3. 비한정적(unbound) 인스턴스 메서드 참조  
- 수신 객체를 특정하지 않는 비한정적 인스턴스 메서드 참조
- 함수 객체를 적용하는 시점에 수신 객체를 알려준다.  
- 이를 위해 수신 객체 전달용 매개변수가 매개변수 목록의 첫 번째로 추가되며, 그 뒤로는 참조되는 메서드 선언에 정의된 매개변수들이 뒤따른다.
- 주로 스트림 파이프라인에서의 매핑과 필터 함수에 쓰인다. (아이템 45)
```Java
//메서드 참조 (타입::메소드명)
String::toLowerCase

//람다
str -> str.toLowerCase()
```
4. 클래스 생성자를 가리키는 메서드 참조
```Java
//메서드 참조 (클래스명::new)
TreeMap<K,V>::new

//람다
() -> new TreeMap<K,V>()
```
5. 배열 생성자를 가리키는 메서드 참조
```Java
//메서드 참조
int[]::new

//람다
len -> new int[len];
```

> ## 핵심 정리
> 메서드 참조는 람다의 간단명료한 대안이 될 수 있다.  
> **메서드 참조 쪽이 짧고 명확하다면 메서드 참조를 쓰고, 그렇지 않을 때만 람다를 사용하라.**

## 제네릭 함수 타입
- 람다로는 불가능하지만 메서드 참조로는 가능한 유일한 예가 제네릭 함수 타입(generic function type) 구현이다.

```Java

// 함수형 인터페이스의 추상 메서드가 제네릭일 수 있듯이 함수 타입도 제네릭일 수 있다.

interface G1 {
    <E extends Exception> Object m() throws E;
}

interface G2 {
    <F extends Exception> String m() throws Exception;
}

interface G extends G1, G2 {}
...

// 이 때 함수형 인터페이스 G를 함수 타입으로 표현하면 다음과 같다.

<F extends Exception> () -> String throws F 

// 이처럼 함수형 인터페이스를 위한 제네릭 함수 타입은 메서드 참조 표현식으로는 구현할 수 있지만, 람다식으로는 불가능하다.  
// 제네릭은 람다식이라는 문법이 존재하지 않기 때문이다.
```



